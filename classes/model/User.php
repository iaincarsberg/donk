<?php

/**
 * Model_User
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
class Model_User extends Model_BaseUser
{
	/**
	 * Contains the auto login user account.
	 * @var Model_User
	 **/
	private static $_auto_login;
	
	/**
	 * Used to fetch a specific user
	 * @param string $username Contains the username you want to grab
	 * @return Model_user
	 */
	public static function fetchByUsername($username)
	{
		return Doctrine_Query::create()
			->from('Model_user u, u.Roles rs, rs.Role r')
			->where('u.username=?', $username)
			->fetchOne();
	}
	
	/**
	 * Used to fetch a specific user by either there username or email address
	 * @param string $unique Contains the username or email you want to grab
	 * @return Model_user
	 */
	public static function fetchByUsernameOrEmail($unique)
	{
		return Doctrine_Query::create()
			->from('Model_user u, u.Roles rs, rs.Role r')
			->where('u.username=?', $unique)
			->orWhere('u.email=?', $unique)
			->fetchOne();
	}
	
	/**
	 * Used to set/get an auto_login user
	 * @param Model_User|false $user Contains a user if were setting the 
	 * auto_login user, or false if we're getting it.
	 * @return Model_User Containing the currently authenticated user
	 */
	public static function auto_login($user = FALSE)
	{
		if ($user) {
			self::$_auto_login = $user;
			
		} else {
			return self::$_auto_login;
		}
		
	}
	
	/**
	 * Used to see if a user has a role
	 * @param string|object|array $role Contains the role we are checking to see if 
	 * a user has been issued.
	 * @return boolean
	 */
	public function has_role($role)
	{
		// If the role is an instance of the Model_Role then we want to
		// extract the roles name.
		if ($role instanceof Model_Role) {
			$role = $role->name;
		}
		
		// If we were parsed an array of roles, then we want to process 
		// that array.
		if (is_array($role) OR $role instanceof Doctrine_Collection) {
			foreach ($role as $r) {
				// Make sure the user hasn't submitted a nested array.
				if (is_array($r)) {
					throw new DONK_Exception("has_role does not support nested arrays.");
				}
				
				// Check to see if this role is owned, if it isn't then 
				// return false.
				if (! $this->has_role($r)) {
					return FALSE;
				}
			}
			
			return TRUE;
			
		// If the role is a string then we want to check to see if this role 
		// is owned by the user.
		} elseif (is_string($role)) {
			foreach ($this->Roles as $r) {
				if (strcmp(strtolower($r->Role->name), strtolower($role)) === 0) {
					return TRUE;
				}
			}
			
		// Otherwise return false.
		} else {
			return FALSE;
		}
	}
	
	/**
	 * Before we save an account we want to check to see if the password 
	 * differs from the stored one, if it does, it means someone has done 
	 * $this->password = 'something new'; in which case we need to hash this 
	 * bad boy.
	 * @param void
	 * @return void
	 */
	public function preSave($event)
	{
		// Hash the new password before to commiting it to disk.
		if (array_key_exists('password', $this->getModified())) {
			$this->password = Auth::instance()->hash($this->password);
		}
	}
	
	/**
	 * Used to keep a track of completed logins
	 * @param void
	 * @return void
	 */
	public function complete_login()
	{
		$this->logins += 1;
		$this->last_login = time();
		$this->failed_login_attempts = 0;
		$this->save();
	}
	
	/**
	 * Called when a user is correctly selected, but fails to have the login
	 * rule, or the correct password.
	 * @param void
	 * @return void
	 */
	public function invalid_login()
	{
		$this->failed_login_attempts += 1;
		
		// If there is a $max_failed_login_attempts and its met then we want 
		// to remove the login privilage from the user.
		// The idea behind this is that even if someone is attempting to gain
		// access to an accout using a brute force attack, and they eventually
		// enter the correct redentials the account will be locked way before
		// this happens, and the correct password will recive a failed 
		// response.
		$max_failed_login_attempts = Kohana::config('donk_auth.max_failed_login_attempts');
		if ($max_failed_login_attempts AND
			$this->failed_login_attempts >= $max_failed_login_attempts) {
			
			// If the user still has the 'login' role, then we want to remove it
			// and trigger an event to inform the owner of the account that 
			// someone has attemped to gain access to there account.
			if ($this->has_role('login')) {
				$role = Doctrine::getTable('Model_Role')
					->findOneByName('login');
				
				Doctrine_Query::create()
					->delete('r')
					->from('Model_Roles_Users r')
					->where('r.user_id=?', $this->id)
					->andWhere('r.role_id=?', $role->id)
					->execute();
				
				DONK_Dispatcher::instance()->trigger_event(
					'donk.auth.user.max_failed_login_attempts_met',
					Dispatcher::event(
						array('user' => $this)
						),
					TRUE
					);
			}
		}
		
		$this->save();
	}
}